<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>بخش 17: تکامل طراحی (از Abstract به Interface) | برنامه‌سازی پیشرفته</title>

    <meta name="description" content="آموزش تکامل طراحی شیءگرا، ریفکتور کردن از کلاس انتزاعی به رابط، و اصول طراحی منعطف در جاوا">

    <link rel="stylesheet" href="../assets/css/themes.css">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>

    <style>
        /* استایل‌های اختصاصی دیاگرام تکامل */
        .diagram-container svg {
            font-family: 'Vazirmatn', 'Segoe UI', sans-serif;
        }
        .uml-class {
            fill: #ffffff;
            stroke: #0891b2; /* cyan-600 */
            stroke-width: 2px;
        }
        .uml-interface {
            fill: #ecfeff; /* cyan-50 */
            stroke: #0e7490; /* cyan-700 */
            stroke-width: 2px;
            stroke-dasharray: 5,5;
        }
        .uml-title {
            font-weight: bold;
            font-size: 14px;
            text-anchor: middle;
            fill: #155e75;
        }
        .uml-text {
            font-size: 12px;
            fill: #164e63;
        }
        .uml-line {
            stroke: #0891b2;
            stroke-width: 1px;
        }
        .relation-line {
            stroke: #0e7490;
            stroke-width: 2px;
            fill: none;
        }
        .table-container th {
            background-color: #0e7490; /* cyan-700 */
            color: white;
        }
        .table-container tr:nth-child(even) {
            background-color: #cffafe; /* cyan-100 */
        }
    </style>
</head>
<body class="theme-part17">

<div id="overlay"></div>

<header id="top-header">
    <button id="menu-toggle">☰</button>
    <h1>17. تکامل طراحی: از کلاس انتزاعی به رابط</h1>
    <div class="breadcrumb">
        <a href="../index.html">خانه</a>
        <span>></span>
        <span>فاز ۴</span>
        <span>></span>
        <span>بخش ۱۷</span>
    </div>
</header>

<nav id="sidebar">
    <div class="sidebar-profile">
        <a href="../index.html" title="بازگشت به صفحه اصلی">
            <img src="../assets/images/university_logo.png" alt="لوگو دانشگاه" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%2314B8A6%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 font-size=%2240%22 fill=%22white%22 text-anchor=%22middle%22 dy=%22.3em%22%3EJ%3C/text%3E%3C/svg%3E'">
        </a>
        <h2>برنامه‌سازی پیشرفته (جاوا)</h2>
        <p>مدرس: سید سجاد پیراهش</p>
    </div>

    <ul class="nav-menu">
        <li>
            <header class="open">فهرست بخش 17</header>
            <ul class="submenu open">
                <li><a href="#intro" class="nav-link">مقدمه</a></li>
                <li><a href="#section-1" class="nav-link">۱. نسخه ۱: طراحی با Abstract Class</a></li>
                <li><a href="#section-2" class="nav-link">۲. نسخه ۲: تکامل با Interface</a></li>
                <li><a href="#section-3" class="nav-link">۳. مقایسه طراحی‌ها و UML</a></li>
                <li><a href="#exercises" class="nav-link">۴. تمرین‌های عملی</a></li>
            </ul>
        </li>
        <li>
            <header>بخش‌های فاز ۴</header>
            <ul class="submenu">
                <li><a href="part14.html" class="nav-link">بخش ۱۴: چندریختی</a></li>
                <li><a href="part15.html" class="nav-link">بخش ۱۵: کلاس‌های انتزاعی</a></li>
                <li><a href="part16.html" class="nav-link">بخش ۱۶: رابط‌ها</a></li>
                <li><a href="part17.html" class="nav-link active">بخش ۱۷: تکامل طراحی</a></li>
            </ul>
        </li>
    </ul>

    <div class="sidebar-footer">
        <a href="../index.html">→ بازگشت به فهرست اصلی</a>
    </div>
</nav>

<main id="main-content">

    <section id="intro">
        <p class="lead">در دو بخش گذشته، ما با دو ابزار قدرتمند برای تعریف قرارداد در جاوا آشنا شدیم: <strong>کلاس‌های انتزاعی</strong> و <strong>رابط‌ها</strong>. اکنون زمان آن رسیده که در یک سناریوی واقعی و عملی، این دو را در کنار هم قرار دهیم، مقایسه کنیم و ببینیم چگونه یک طراحی خوب می‌تواند به یک طراحی عالی تکامل پیدا کند.</p>
        <p>ما قصد داریم یک برنامه نقاشی ساده بسازیم. این مسیر را در دو نسخه طی خواهیم کرد:</p>
        <ul>
            <li><strong>نسخه ۱:</strong> یک طراحی اولیه با استفاده از <code>abstract class Shape</code>.</li>
            <li><strong>نسخه ۲:</strong> تکامل طراحی با استفاده از <code>interface Drawable</code> برای دستیابی به انعطاف‌پذیری نهایی.</li>
        </ul>
    </section>

    <section id="section-1">
        <h2>۱. نسخه ۱: طراحی با کلاس انتزاعی <code>Shape</code> (یک شروع خوب)</h2>

        <p>فرض اولیه ما این است که در برنامه ما، "هر چیزی که قابل رسم است، یک شکل هندسی است". این یک فرض منطقی برای شروع است. اشکال هندسی مانند دایره، مستطیل و خط، ویژگی‌های مشترک زیادی دارند (مانند رنگ، نقطه شروع) و همگی نوعی "شکل" هستند (رابطه IS-A). این شرایط، <code>abstract class</code> را به گزینه‌ای ایده‌آل تبدیل می‌کند.</p>

        <h3>کدهای پیاده‌سازی نسخه ۱</h3>

        <p><strong>کلاس <code>Point.java</code> (یک کلاس کمکی):</strong></p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">public class Point {
    private int x, y;
    // Constructors, getters, setters...
    public Point(int x, int y) { this.x = x; this.y = y; }
    @Override
    public String toString() { return "(" + x + "," + y + ")"; }
}</code></pre>
        </div>

        <p><strong>کلاس انتزاعی <code>Shape.java</code>:</strong></p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">import java.awt.Color;

public abstract class Shape {
    protected Color color;
    protected Point origin;

    public Shape(Color color, Point origin) {
        this.color = color;
        this.origin = origin;
    }

    // متد انتزاعی: هر فرزندی باید روش رسم خودش را تعریف کند
    public abstract void draw();
}</code></pre>
        </div>

        <p><strong>کلاس‌های انضمامی (Concrete Subclasses):</strong></p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">// Circle.java
public class Circle extends Shape {
    private int radius;
    public Circle(Color color, Point origin, int radius) {
        super(color, origin);
        this.radius = radius;
    }
    @Override
    public void draw() {
        System.out.println("Drawing Circle at " + origin + " with radius " + radius);
    }
}

// Rectangle.java
public class Rectangle extends Shape {
    private int width, height;
    // ... Constructor ...
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle at " + origin + " with width/height: " + width + "," + height);
    }
}</code></pre>
        </div>

        <p><strong>کلاس اصلی <code>PaintingArea.java</code>:</strong></p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
import java.awt.Color;

public class PaintingArea {
    public static void main(String[] args) {
        List<Shape> shapes = new ArrayList<>();

        shapes.add(new Circle(Color.RED, new Point(10, 10), 5));
        shapes.add(new Rectangle(Color.BLUE, new Point(20, 30), 15, 25));

        System.out.println("--- Drawing all shapes ---");
        for (Shape s : shapes) {
            s.draw(); // قدرت چندریختی در عمل
        }
    }
}</code></pre>
        </div>

        <div class="warning-box">
            <strong>تحلیل نسخه ۱:</strong>
            <p>این طراحی کاملاً خوب و شیءگرا است. اما محدودیت بزرگ کجاست؟</p>
            <p>سوال: اگر بخواهیم یک <code>Image</code> (تصویر) یا یک <code>TextLabel</code> (برچسب متنی) را به صفحه نقاشی خود اضافه کنیم، چه؟</p>
            <ul>
                <li>یک <code>Image</code> <strong>یک</strong> <code>Shape</code> نیست.</li>
                <li>یک <code>TextLabel</code> <strong>یک</strong> <code>Shape</code> نیست.</li>
            </ul>
            <p>آن‌ها نمی‌توانند از <code>Shape</code> ارث‌بری کنند. طراحی ما به بن‌بست رسیده است.</p>
        </div>
    </section>

    <section id="section-2">
        <h2>۲. نسخه ۲: تکامل با رابط <code>Drawable</code> (انعطاف‌پذیری حداکثری)</h2>

        <p>مشکل نسخه ۱ این بود که ما "چیستی" یک شیء (Shape) را با "توانایی" آن (قابل رسم بودن) گره زدیم. راه‌حل، جدا کردن این دو مفهوم است.</p>

        <h3>گام ۱: تعریف قرارداد خالص با <code>interface Drawable</code></h3>
        <p>ما یک رابط تعریف می‌کنیم که فقط یک چیز را مشخص می‌کند: "هر چیزی که می‌خواهد قابل رسم باشد، باید متد <code>draw()</code> را داشته باشد."</p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">public interface Drawable {
    void draw(); // public abstract
}</code></pre>
        </div>

        <h3>گام ۲: ریفکتور کردن سلسله‌مراتب <code>Shape</code></h3>
        <p>اکنون، <code>Shape</code> به جای تعریف <code>draw</code>، قرارداد <code>Drawable</code> را پیاده‌سازی می‌کند.</p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">// Shape.java (نسخه ۲)
// Shape خودش یک چیز قابل رسم است
public abstract class Shape implements Drawable {
    protected Color color;
    protected Point origin;

    public Shape(Color color, Point origin) {
        this.color = color;
        this.origin = origin;
    }

    // متد draw همچنان abstract باقی می‌ماند تا فرزندان آن را پیاده‌سازی کنند
    @Override
    public abstract void draw();
}</code></pre>
        </div>
        <p>کلاس‌های <code>Circle</code> و <code>Rectangle</code> بدون هیچ تغییری همچنان کار می‌کنند، زیرا آن‌ها <code>draw()</code> را از قبل پیاده‌سازی کرده‌اند.</p>

        <h3>گام ۳: افزودن کلاس‌های نامرتبط</h3>
        <p>حالا می‌توانیم هر کلاس دیگری را "قابل رسم" کنیم.</p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">// یک کلاس کاملاً نامرتبط
public class Image implements Drawable {
    private String filePath;

    public Image(String filePath) { this.filePath = filePath; }

    @Override
    public void draw() {
        System.out.println("Drawing image from: " + filePath);
    }
}

public class TextLabel implements Drawable {
    private String text;
    private Point position;

    public TextLabel(String text, Point position) { /* ... */ }

    @Override
    public void draw() {
        System.out.println("Drawing text '" + text + "' at " + position);
    }
}</code></pre>
        </div>

        <h3>گام ۴: به‌روزرسانی <code>PaintingArea</code> برای کار با <code>Drawable</code></h3>
        <p>کلاس اصلی ما دیگر به <code>Shape</code> وابسته نیست، بلکه به قرارداد <code>Drawable</code> وابسته است.</p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">// PaintingArea.java (نسخه ۲)
public class PaintingArea {
    public static void main(String[] args) {
        // لیست ما اکنون هر چیز "قابل رسم" را می‌پذیرد!
        List<Drawable> drawableObjects = new ArrayList<>();

        // افزودن انواع مختلف اشیاء
        drawableObjects.add(new Circle(Color.RED, new Point(10, 10), 5));
        drawableObjects.add(new Rectangle(Color.BLUE, new Point(20, 30), 15, 25));
        drawableObjects.add(new Image("C:/logo.png"));
        drawableObjects.add(new TextLabel("Hello OOP!", new Point(50, 50)));

        System.out.println("--- Drawing everything ---");
        for (Drawable d : drawableObjects) {
            d.draw(); // فراخوانی متد draw برای هر شیء، فارغ از نوع واقعی آن
        }
    }
}</code></pre>
        </div>
    </section>

    <section id="section-3">
        <h2>۳. مقایسه طراحی‌ها و نمودار UML</h2>

        <div class="table-container">
            <table>
                <thead>
                <tr>
                    <th>معیار</th>
                    <th>نسخه ۱ (Abstract Class <code>Shape</code>)</th>
                    <th>نسخه ۲ (Interface <code>Drawable</code>)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>نوع رابطه</strong></td>
                    <td><strong>IS-A (هست یک):</strong> همه چیز باید یک <code>Shape</code> باشد.</td>
                    <td><strong>CAN-DO (می‌تواند...):</strong> هر چیزی می‌تواند <code>Drawable</code> باشد.</td>
                </tr>
                <tr>
                    <td><strong>انعطاف‌پذیری</strong></td>
                    <td><strong>پایین:</strong> محدود به یک سلسله‌مراتب وراثت.</td>
                    <td><strong>بسیار بالا:</strong> کلاس‌ها از هر سلسله‌مراتب می‌توانند رابط را پیاده‌سازی کنند.</td>
                </tr>
                <tr>
                    <td><strong>اشتراک‌گذاری کد</strong></td>
                    <td><strong>قوی:</strong> کلاس <code>Shape</code> می‌تواند فیلدها و متدهای مشترک را به اشتراک بگذارد.</td>
                    <td><strong>ضعیف:</strong> رابط (قبل از جاوا ۸) هیچ کدی را به اشتراک نمی‌گذارد.</td>
                </tr>
                <tr>
                    <td><strong>محدودیت اصلی</strong></td>
                    <td>عدم امکان افزودن کلاس‌های نامرتبط (مثل <code>Image</code>).</td>
                    <td>نیاز به پیاده‌سازی مجدد رفتار در کلاس‌هایی که کد مشترک ندارند.</td>
                </tr>
                <tr>
                    <td><strong>اصل طراحی</strong></td>
                    <td>وابستگی به یک پیاده‌سازی انتزاعی.</td>
                    <td><strong>وابستگی به یک قرارداد (Program to an interface).</strong></td>
                </tr>
                </tbody>
            </table>
        </div>

        <h3>نمودار UML کامل (نسخه ۲)</h3>
        <div class="diagram-container">
            <svg viewBox="0 0 800 500" xmlns="http://www.w3.org/2000/svg" dir="ltr">
                <defs>
                    <marker id="arrowEmpty" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="white" stroke="#0891b2" stroke-width="1"/>
                    </marker>
                    <marker id="arrowDashed" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="white" stroke="#0e7490" stroke-width="1"/>
                    </marker>
                    <marker id="diamondEmpty" markerWidth="12" markerHeight="12" refX="11" refY="6" orient="auto">
                        <polygon points="0 6, 6 0, 12 6, 6 12" fill="white" stroke="#0891b2" stroke-width="1"/>
                    </marker>
                </defs>

                <!-- Drawable Interface -->
                <rect x="350" y="20" width="140" height="60" class="uml-interface"/>
                <text x="420" y="40" class="uml-title">&lt;&lt;interface&gt;&gt;</text>
                <text x="420" y="55" class="uml-title">Drawable</text>
                <line x1="350" y1="60" x2="490" y2="60" class="uml-line"/>
                <text x="420" y="75" class="uml-text" text-anchor="middle">+ draw()</text>

                <!-- Shape Abstract Class -->
                <rect x="150" y="150" width="160" height="100" class="uml-class" stroke-dasharray="5,2"/>
                <text x="230" y="170" class="uml-title" font-style="italic">Shape</text>
                <line x1="150" y1="180" x2="310" y2="180" class="uml-line"/>
                <text x="160" y="195" class="uml-text"># color: Color</text>
                <text x="160" y="210" class="uml-text"># origin: Point</text>
                <line x1="150" y1="220" x2="310" y2="220" class="uml-line"/>
                <text x="160" y="235" class="uml-text" font-style="italic">+ draw()</text>

                <!-- Point Class -->
                <rect x="20" y="280" width="100" height="60" class="uml-class"/>
                <text x="70" y="300" class="uml-title">Point</text>
                <line x1="20" y1="310" x2="120" y2="310" class="uml-line"/>
                <text x="30" y="325" class="uml-text">- x, y: int</text>

                <!-- Aggregation: Shape o-- Point -->
                <line x1="120" y1="310" x2="150" y2="250" class="relation-line"/>
                <path d="M 150 250 L 160 230" class="relation-line" marker-end="url(#diamondEmpty)"/>

                <!-- Circle Class -->
                <rect x="50" y="380" width="140" height="60" class="uml-class"/>
                <text x="120" y="400" class="uml-title">Circle</text>
                <line x1="50" y1="410" x2="190" y2="410" class="uml-line"/>
                <text x="60" y="425" class="uml-text">+ draw()</text>

                <!-- Rectangle Class -->
                <rect x="210" y="380" width="140" height="60" class="uml-class"/>
                <text x="280" y="400" class="uml-title">Rectangle</text>
                <line x1="210" y1="410" x2="350" y2="410" class="uml-line"/>
                <text x="220" y="425" class="uml-text">+ draw()</text>

                <!-- Image Class -->
                <rect x="400" y="250" width="140" height="60" class="uml-class"/>
                <text x="470" y="270" class="uml-title">Image</text>
                <line x1="400" y1="280" x2="540" y2="280" class="uml-line"/>
                <text x="410" y="295" class="uml-text">+ draw()</text>

                <!-- TextLabel Class -->
                <rect x="560" y="250" width="140" height="60" class="uml-class"/>
                <text x="630" y="270" class="uml-title">TextLabel</text>
                <line x1="560" y1="280" x2="700" y2="280" class="uml-line"/>
                <text x="570" y="295" class="uml-text">+ draw()</text>

                <!-- Realization: Shape ..|> Drawable -->
                <path d="M 230 150 L 230 120 L 400 120 L 400 80" class="relation-line" stroke-dasharray="5,5" marker-end="url(#arrowDashed)"/>

                <!-- Realization: Image ..|> Drawable -->
                <path d="M 470 250 L 470 80" class="relation-line" stroke-dasharray="5,5" marker-end="url(#arrowDashed)"/>

                <!-- Realization: TextLabel ..|> Drawable -->
                <path d="M 630 250 L 630 120 L 440 120" class="relation-line" stroke-dasharray="5,5" marker-end="url(#arrowDashed)"/>

                <!-- Inheritance: Circle --|> Shape -->
                <path d="M 120 380 L 120 350 L 200 350 L 200 250" class="relation-line" marker-end="url(#arrowEmpty)"/>

                <!-- Inheritance: Rectangle --|> Shape -->
                <path d="M 280 380 L 280 350 L 260 350 L 260 250" class="relation-line" marker-end="url(#arrowEmpty)"/>

            </svg>
        </div>
    </section>

    <section id="exercises">
        <h2>۴. تمرین‌های عملی</h2>

        <div class="exercise-box">
            <h3>تمرین ۱: افزودن <code>VideoClip</code></h3>
            <p>یک کلاس <code>VideoClip</code> بسازید که دارای فیلد <code>duration</code> باشد. این کلاس را طوری تغییر دهید که در <code>PaintingArea</code> قابل رسم باشد (فقط یک پیام چاپ کند که "Playing video...").</p>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۲: افزودن رابط <code>Saveable</code></h3>
            <p>یک رابط جدید به نام <code>Saveable</code> با متد <code>saveToFile(String path)</code> تعریف کنید.</p>
            <ol>
                <li>کلاس <code>Shape</code> را تغییر دهید تا این رابط را پیاده‌سازی کند.</li>
                <li>کلاس <code>Image</code> را نیز تغییر دهید تا <code>Saveable</code> باشد.</li>
                <li>یک متد در <code>main</code> بنویسید که لیستی از <code>Saveable</code> ها را بگیرد و همه را ذخیره کند.</li>
            </ol>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۳: طراحی سیستم صوتی</h3>
            <p>یک سیستم پخش موسیقی را با استفاده از رابط‌ها طراحی کنید:</p>
            <ul>
                <li>رابط <code>Playable</code> با متدهای <code>play()</code> و <code>stop()</code>.</li>
                <li>کلاس <code>Mp3File</code> و <code>PodcastStream</code> که <code>Playable</code> را پیاده‌سازی می‌کنند.</li>
                <li>یک کلاس <code>MusicPlayer</code> که بتواند لیستی از <code>Playable</code> ها را پخش کند.</li>
            </ul>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۴: پیاده‌سازی کامل سیستم Audio</h3>
            <p>سیستم کامل برای پخش صدا طراحی کنید:</p>
            <ol>
                <li>رابط <code>Playable</code> با متدهای <code>play()</code>, <code>pause()</code>, <code>stop()</code>.</li>
                <li>کلاس انتزاعی <code>AudioFile</code> که رابط را پیاده‌سازی کرده و فیلد <code>filename</code> دارد.</li>
                <li>دو کلاس <code>Mp3File</code> و <code>WavFile</code> که از <code>AudioFile</code> ارث می‌برند.</li>
                <li>کلاس <code>Playlist</code> که متد <code>playAll()</code> دارد.</li>
            </ol>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۵: مقایسه طراحی‌ها (Design Comparison)</h3>
            <p>فرض کنید می‌خواهید یک سیستم برای وسایل نقلیه (<code>Vehicle</code>) طراحی کنید. سه روش زیر را پیاده‌سازی و مقایسه کنید:</p>
            <ul>
                <li><strong>طراحی A:</strong> فقط Abstract Class.</li>
                <li><strong>طراحی B:</strong> فقط Interface.</li>
                <li><strong>طراحی C:</strong> ترکیب (Abstract implements Interface).</li>
            </ul>
            <p><strong>سوال:</strong> اگر بخواهید یک <code>FlyingCar</code> بسازید که هم رانندگی می‌کند (<code>Drivable</code>) و هم پرواز می‌کند (<code>Flyable</code>)، کدام طراحی بهتر است؟</p>
        </div>
    </section>

    <section id="summary">
        <h2>خلاصه بخش هفدهم</h2>
        <div class="summary-box">
            <ul>
                <li>✅ <strong>شروع با Abstract Class:</strong> برای خانواده‌ای از اشیاء نزدیک (IS-A) عالی است.</li>
                <li>✅ <strong>تکامل با Interface:</strong> برای تعریف توانایی (CAN-DO) و شکستن محدودیت وراثت ضروری است.</li>
                <li>✅ <strong>اصل کلیدی:</strong> "Program to an interface, not an implementation."</li>
                <li>✅ <strong>ترکیب قدرتمند:</strong> استفاده همزمان از کلاس انتزاعی (برای کد مشترک) و رابط (برای انعطاف‌پذیری) بهترین الگو است.</li>
            </ul>
        </div>

        <div class="next-section">
            <p><strong>در بخش بعدی:</strong> چارچوب کلکسیون‌ها (Collections Framework) — جعبه ابزار داده‌ها</p>
            <div class="part-navigation">
                <a href="part16.html" class="btn-prev">→ بخش قبلی</a>
                <a href="part18.html" class="btn-next">بخش بعدی: کلکسیون‌ها ←</a>
            </div>
        </div>
    </section>
</main>

<script src="../assets/js/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>

</body>
</html>