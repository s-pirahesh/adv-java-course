<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>بخش 11: ارث‌بری | برنامه‌سازی پیشرفته</title>
    <link rel="icon" type="image/icon" href="../assets/images/favicon.ico">
    <meta name="description" content="آموزش جامع ارث‌بری (Inheritance) در جاوا، کلمه کلیدی extends، super و انتخاب بین ارث‌بری و ترکیب (Composition)">

    <link rel="stylesheet" href="../assets/css/themes.css">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>

    <style>
        /* استایل‌های اختصاصی بخش ارث‌بری */
        .comparison-table th {
            background-color: #4338ca; /* indigo-700 */
            color: white;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #e0e7ff; /* indigo-50 */
        }
        .keyword-badge {
            background-color: #eef2ff;
            color: #3730a3;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            border: 1px solid #c7d2fe;
        }
    </style>
</head>
<body class="theme-part11">

<div id="overlay"></div>

<header id="top-header">
    <button id="menu-toggle">☰</button>
    <h1>11. ارث‌بری: ستون فقرات سلسله‌مراتب شیءگرا</h1>
    <div class="breadcrumb">
        <a href="../index.html">خانه</a>
        <span>></span>
        <span>فاز ۳</span>
        <span>></span>
        <span>بخش ۱۱</span>
    </div>
</header>

<nav id="sidebar">
    <div class="sidebar-profile">
        <a href="../index.html" title="بازگشت به صفحه اصلی">
            <img src="../assets/images/university_logo.png" alt="لوگو دانشگاه" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%2314B8A6%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 font-size=%2240%22 fill=%22white%22 text-anchor=%22middle%22 dy=%22.3em%22%3EJ%3C/text%3E%3C/svg%3E'">
        </a>
        <h2>برنامه‌سازی پیشرفته (جاوا)</h2>
        <p>مدرس: سید سجاد پیراهش</p>
    </div>

    <ul class="nav-menu">
        <li>
            <header class="open">فهرست بخش 11</header>
            <ul class="submenu open">
                <li><a href="#intro" class="nav-link">مقدمه</a></li>
                <li><a href="#section-1" class="nav-link">۱. مشکل تکرار کد</a></li>
                <li><a href="#section-2" class="nav-link">۲. راه‌حل: ارث‌بری (extends)</a></li>
                <li><a href="#section-3" class="nav-link">۳. Composition vs Inheritance</a></li>
                <li><a href="#section-4" class="nav-link">۴. سطوح دسترسی</a></li>
                <li><a href="#section-5" class="nav-link">۵. سازنده‌ها و super</a></li>
                <li><a href="#section-6" class="nav-link">۶. اشتباهات رایج</a></li>
                <li><a href="#exercises" class="nav-link">۷. تمرین‌های عملی</a></li>
            </ul>
        </li>
        <li>
            <header>بخش‌های فاز ۳</header>
            <ul class="submenu">
                <li><a href="part11.html" class="nav-link active">بخش ۱۱: ارث‌بری</a></li>
                <li><a href="part12.html" class="nav-link">بخش ۱۲: Casting</a></li>
                <li><a href="part13.html" class="nav-link">بخش ۱۳: بازنویسی متدها</a></li>
                <li><a href="part14.html" class="nav-link">بخش ۱۴: چندریختی</a></li>
            </ul>
        </li>
    </ul>

    <div class="sidebar-footer">
        <a href="../index.html">→ بازگشت به فهرست اصلی</a>
    </div>
</nav>

<main id="main-content">

    <section id="intro">
        <p class="lead">تا به اینجا، ما کلاس‌ها را به عنوان موجودیت‌های مستقل و جدا از هم طراحی کرده‌ایم. اما در دنیای واقعی، مفاهیم و اشیاء در یک شبکه پیچیده از روابط و دسته‌بندی‌ها قرار دارند. یک "شیر" فقط یک شیر نیست؛ بلکه یک "گربه‌سان" است، که خود یک "پستاندار" است، و در نهایت یک "حیوان" است. هر کدام از این دسته‌بندی‌ها، ویژگی‌ها و رفتارهای مشترکی را به سطوح پایین‌تر منتقل می‌کنند.</p>
        <p><strong>ارث‌بری (Inheritance)</strong>، یکی از چهار ستون اصلی و قدرتمند برنامه‌نویسی شیءگرا (OOP)، مکانیزمی است که به ما اجازه می‌دهد این روابط سلسله‌مراتبی طبیعی را مستقیماً در کد خود مدل‌سازی کنیم. این ویژگی، سنگ بنای <strong>استفاده مجدد از کد (Code Reusability)</strong> و ایجاد <strong>سلسله‌مراتب انتزاعی (Abstraction Hierarchies)</strong> است.</p>
    </section>

    <section id="section-1">
        <h2>۱. مشکل: بمب ساعتی تکرار کد</h2>
        <p>بیایید با یک سناریوی واقعی شروع کنیم. فرض کنید در حال ساخت یک بازی ویدئویی هستید و چندین نوع شخصیت غیرقابل بازی (NPC) دارید: یک <code>Goblin</code>، یک <code>Orc</code> و یک <code>Dragon</code>.</p>

        <p><strong>کدنویسی بدون ارث‌بری (رویکرد فاجعه‌بار):</strong></p>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">public class Goblin {
    // ویژگی‌ها
    private int health = 100;
    private int attackPower = 10;
    private String name;

    // رفتارها
    public void takeDamage(int amount) {
        this.health -= amount;
        System.out.println(name + " takes " + amount + " damage!");
    }
    public void attack(Player target) {
        target.takeDamage(this.attackPower);
    }
    // ... سایر متدهای Goblin
}

public class Orc {
    // -- تکرار کد --
    private int health = 150;
    private int attackPower = 20;
    private String name;

    public void takeDamage(int amount) { // متد تکراری
        this.health -= amount;
        System.out.println(name + " takes " + amount + " damage!");
    }
    public void attack(Player target) { // متد تکراری
        target.takeDamage(this.attackPower);
    }
    // ... سایر متدهای Orc
}</code></pre>
        </div>

        <div class="warning-box">
            <strong>تحلیل مشکلات:</strong>
            <ol>
                <li><strong>نقض کامل اصل DRY (Don't Repeat Yourself):</strong> منطق <code>takeDamage</code> و <code>attack</code> دقیقاً در هر دو کلاس کپی شده است. این فقط کد نیست که تکرار شده، بلکه "دانش" و "منطق" تکرار شده است.</li>
                <li><strong>نگهداری غیرممکن:</strong> تصور کنید بخواهید یک ویژگی جدید مثل "شانس جاخالی دادن (Dodge Chance)" را به <code>takeDamage</code> اضافه کنید. شما باید به <strong>تک‌تک</strong> فایل‌های دشمنان بروید و این منطق را اضافه کنید. فراموش کردن یک کلاس، به معنی ایجاد یک باگ خطرناک در بازی است.</li>
                <li><strong>عدم وجود رابطه منطقی:</strong> از دید کامپایلر، <code>Goblin</code> و <code>Orc</code> هیچ ربطی به هم ندارند. شما نمی‌توانید یک تابع بنویسید که "هر نوع دشمنی" را به عنوان ورودی بگیرد.</li>
            </ol>
        </div>
    </section>

    <section id="section-2">
        <h2>۲. راه‌حل: استخراج ویژگی‌های مشترک (رابطه "Is-A")</h2>
        <p>ارث‌بری به ما می‌گوید: "به جای تکرار، ویژگی‌های مشترک را در یک کلاس عمومی‌تر و پایه‌ای‌تر قرار بده." این کلاس عمومی، <strong>کلاس والد (Superclass/Parent)</strong> نامیده می‌شود.</p>

        <p>این رابطه، یک رابطه <strong>"هست یک" (IS-A Relationship)</strong> است:</p>
        <ul>
            <li>یک <code>Goblin</code> <strong>هست یک</strong> <code>Enemy</code>.</li>
            <li>یک <code>Orc</code> <strong>هست یک</strong> <code>Enemy</code>.</li>
        </ul>

        <h3>گام ۱: ساخت کلاس والد (Enemy)</h3>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">// Enemy تمام دانش و رفتار مشترک دشمنان را در خود دارد
public class Enemy {
    protected String name;
    protected int health;
    protected int attackPower;

    public Enemy(String name, int health, int attackPower) {
        this.name = name;
        this.health = health;
        this.attackPower = attackPower;
    }

    public void takeDamage(int amount) {
        this.health -= amount;
        System.out.println(this.name + " takes " + amount + " damage. Health: " + this.health);
    }

    public void attack(Player target) {
        System.out.println(this.name + " attacks " + target.getName() + "!");
        target.takeDamage(this.attackPower);
    }
}</code></pre>
        </div>

        <h3>گام ۲: ساخت کلاس‌های فرزند با <code>extends</code></h3>
        <p>کلاس‌های فرزند اکنون بسیار تمیزتر و متمرکزتر بر روی ویژگی‌های <strong>اختصاصی</strong> خود هستند.</p>

        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">// Goblin از Enemy ارث می‌برد و تمام فیلدها و متدهای public/protected آن را به ارث می‌برد
public class Goblin extends Enemy {
    // سازنده Goblin، سازنده Enemy را فراخوانی می‌کند
    public Goblin(String name) {
        super(name, 100, 10); // پاس دادن مقادیر به والد
    }

    // رفتار اختصاصی Goblin
    public void steal() {
        System.out.println(this.name + " steals your gold!");
    }
}

public class Dragon extends Enemy {
    public Dragon(String name) {
        super(name, 500, 50);
    }

    // رفتار اختصاصی Dragon
    public void breatheFire() {
        System.out.println(this.name + " breathes fire everywhere!");
    }
}</code></pre>
        </div>

        <p><strong>مزایا:</strong></p>
        <ul>
            <li>منطق <code>takeDamage</code> فقط در یک مکان نوشته شده است.</li>
            <li>برای افزودن ویژگی جدید، فقط کلاس <code>Enemy</code> را ویرایش می‌کنیم.</li>
            <li>اکنون یک رابطه منطقی داریم: <code>Goblin</code> و <code>Dragon</code> هر دو از نوع <code>Enemy</code> هستند. (این موضوع در بخش چندریختی اهمیت پیدا می‌کند).</li>
        </ul>
    </section>

    <section id="section-3">
        <h2>۳. دو راهی بزرگ طراحی: Composition (HAS-A) vs. Inheritance (IS-A)</h2>
        <p>شاید مهم‌ترین تصمیم در طراحی شیءگرا، انتخاب بین این دو باشد. تازه‌کارها به اشتباه برای هر نوع استفاده مجدد از کد، به سراغ ارث‌بری می‌روند.</p>

        <p><strong>اصل طلایی:</strong> <strong>Favor Composition over Inheritance (ترکیب را بر ارث‌بری ترجیح بده).</strong></p>

        <div class="table-container">
            <table class="comparison-table">
                <thead>
                <tr>
                    <th>معیار مقایسه</th>
                    <th>Inheritance (ارث‌بری)</th>
                    <th>Composition (ترکیب)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>نوع رابطه</strong></td>
                    <td><strong>IS-A (هست یک):</strong> یک رابطه هویتی و ذاتی است. <code>Dog</code> یک <code>Animal</code> است.</td>
                    <td><strong>HAS-A (دارد یک):</strong> یک رابطه مالکیتی یا عملکردی است. <code>Car</code> یک <code>Engine</code> دارد.</td>
                </tr>
                <tr>
                    <td><strong>وابستگی (Coupling)</strong></td>
                    <td><strong>بسیار بالا (Tight Coupling):</strong> فرزند به شدت به پیاده‌سازی داخلی والد وابسته است. تغییر در والد (مثلاً تغییر یک متد <code>protected</code>) می‌تواند تمام فرزندان را دچار مشکل کند.</td>
                    <td><strong>بسیار پایین (Loose Coupling):</strong> کلاس‌ها از طریق رابط‌های عمومی (public API) با هم صحبت می‌کنند و از جزئیات داخلی هم بی‌خبرند.</td>
                </tr>
                <tr>
                    <td><strong>انعطاف‌پذیری</strong></td>
                    <td><strong>کم (استاتیک):</strong> رابطه در زمان کامپایل ثابت می‌شود. یک <code>Dog</code> نمی‌تواند در زمان اجرا به <code>Cat</code> تبدیل شود.</td>
                    <td><strong>زیاد (دینامیک):</strong> می‌توان اجزاء را در زمان اجرا تغییر داد. یک <code>Car</code> می‌تواند موتور خود را با یک موتور قوی‌تر تعویض کند.</td>
                </tr>
                <tr>
                    <td><strong>دسترسی به کد</strong></td>
                    <td><strong>دسترسی مستقیم:</strong> فرزند به تمام اعضای <code>public</code> و <code>protected</code> والد دسترسی مستقیم دارد (که می‌تواند خطرناک باشد).</td>
                    <td><strong>دسترسی کنترل‌شده:</strong> کلاس "کل" فقط به متدهای <code>public</code> "جزء" دسترسی دارد و کپسوله‌سازی را نمی‌شکند.</td>
                </tr>
                <tr>
                    <td><strong>چندریختی</strong></td>
                    <td><strong>طبیعی و ذاتی:</strong> ارث‌بری، اساس چندریختی (Polymorphism) است.</td>
                    <td><strong>نیاز به طراحی با Interface:</strong> برای دستیابی به چندریختی، باید از طریق Interfaceها طراحی شود.</td>
                </tr>
                <tr>
                    <td><strong>مشکلات طراحی</strong></td>
                    <td><strong>"سلسله‌مراتب شکننده" (Fragile Base Class):</strong> تغییرات کوچک در والد، اثرات غیرمنتظره‌ای در فرزندان دارد. <strong>"مشکل مربع-مستطیل":</strong> نقض اصل Liskov.</td>
                    <td><strong>"جهنم Wrapperها":</strong> گاهی برای فراهم کردن یک رابط کاربری ساده، نیاز به نوشتن متدهای Wrapper زیادی است.</td>
                </tr>
                <tr>
                    <td><strong>چه زمانی استفاده شود؟</strong></td>
                    <td><strong>فقط و فقط</strong> زمانی که رابطه "IS-A" صد در صد برقرار است و فرزند واقعاً یک نوع خاص از والد است.</td>
                    <td>در <strong>اکثر موارد دیگر</strong>. برای استفاده مجدد از عملکرد، مدل‌سازی مالکیت و ایجاد ساختارهای انعطاف‌پذیر.</td>
                </tr>
                </tbody>
            </table>
        </div>
    </section>

    <section id="section-4">
        <h2>۴. سطوح دسترسی (Access Modifiers) در ارث‌بری</h2>
        <p>ارث‌بری بدون درک عمیق سطوح دسترسی، می‌تواند به شدت خطرناک باشد.</p>

        <div class="table-container">
            <table>
                <thead>
                <tr>
                    <th>سطح دسترسی والد</th>
                    <th>کلمه کلیدی</th>
                    <th>دسترسی فرزند (همان پکیج)</th>
                    <th>دسترسی فرزند (پکیج دیگر)</th>
                    <th>توضیح و مثال</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>خصوصی</strong></td>
                    <td><code>private</code></td>
                    <td>❌</td>
                    <td>❌</td>
                    <td><strong>فلسفه:</strong> <code>private</code> یعنی "راز مطلق کلاس". حتی فرزند حق دانستن آن را ندارد. <code>private int secretCode;</code> در والد، در فرزند دیده نمی‌شود.</td>
                </tr>
                <tr>
                    <td><strong>پکیج</strong></td>
                    <td><code>(default)</code></td>
                    <td>✅</td>
                    <td>❌</td>
                    <td><strong>فلسفه:</strong> "راز خانوادگی در یک محله". فرزندان هم‌محله (هم‌پکیج) آن را می‌دانند، اما فرزندان غریبه (پکیج دیگر) نه. <code>String familyName;</code></td>
                </tr>
                <tr>
                    <td><strong>محافظت‌شده</strong></td>
                    <td><code>protected</code></td>
                    <td>✅</td>
                    <td>✅</td>
                    <td><strong>فلسفه:</strong> "راز خانوادگی برای تمام نسل‌ها". این سطح دسترسی <strong>دقیقاً برای ارث‌بری</strong> طراحی شده. <code>protected String heirloom;</code></td>
                </tr>
                <tr>
                    <td><strong>عمومی</strong></td>
                    <td><code>public</code></td>
                    <td>✅</td>
                    <td>✅</td>
                    <td><strong>فلسفه:</strong> "دانش عمومی". همه، از جمله فرزندان، آن را می‌دانند. <code>public String name;</code></td>
                </tr>
                </tbody>
            </table>
        </div>
    </section>

    <section id="section-5">
        <h2>۵. سازنده‌ها و کلمه کلیدی حیاتی <code>super</code></h2>
        <p><strong>قانون شماره یک:</strong> سازنده‌ها به ارث <strong>نمی‌رسند</strong>.</p>
        <p><strong>قانون شماره دو:</strong> هر کلاس مسئول ساختن خودش است، اما قبل از آن باید والدش ساخته شود.</p>

        <p>کلمه کلیدی <code>super</code> یک ارجاع به <strong>کلاس والد</strong> است و دو کاربرد اصلی دارد:</p>
        <ol>
            <li><strong><code>super(...)</code>:</strong> فراخوانی <strong>سازنده</strong> والد.</li>
            <li><strong><code>super.method()</code>:</strong> فراخوانی <strong>متد</strong> والد.</li>
        </ol>

        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
        System.out.println("1. Animal constructor called for: " + name);
    }

    public void eat() {
        System.out.println("3. Animal eating generic food.");
    }
}

class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        // خط اول: فراخوانی سازنده والد. اگر این خط نباشد و والد سازنده پیش‌فرض نداشته باشد، کد کامپایل نمی‌شود.
        super(name);
        System.out.println("2. Dog constructor called.");
        this.breed = breed;
    }

    @Override
    public void eat() {
        // فراخوانی نسخه والد برای انجام کارهای پایه‌ای
        super.eat();
        // افزودن رفتار تخصصی فرزند
        System.out.println("4. Dog is now eating bones.");
    }
}

// Dog myDog = new Dog("Rex", "German Shepherd");
// myDog.eat();</code></pre>
        </div>

        <p><strong>خروجی اجرای کد بالا:</strong></p>
        <pre class="bg-gray-100 p-4 rounded-lg text-sm font-mono text-gray-800">
1. Animal constructor called for: Rex
2. Dog constructor called.
3. Animal eating generic food.
4. Dog is now eating bones.</pre>
    </section>

    <section id="section-6">
        <h2>۶. اشتباهات رایج و تله‌های طراحی</h2>

        <h3>الف) فراموش کردن <code>super()</code> و "سازنده پیش‌فرض کجاست؟"</h3>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">class Vehicle {
    public Vehicle(int speed) { /* ... */ } // سازنده پیش‌فرض ندارد
}
class Car extends Vehicle {
    public Car() {
        // خطای کامپایل!
        // کامپایلر به صورت خودکار `super();` را اینجا قرار می‌دهد،
        // اما سازنده Vehicle() وجود ندارد.
        // راه حل: super(100);
    }
}</code></pre>
        </div>

        <h3>ب) استفاده اشتباه از Is-A: مشکل مربع-مستطیل (نقض اصل Liskov)</h3>
        <p>این یک مثال کلاسیک در طراحی OOP است.</p>
        <ul>
            <li><strong>تفکر اولیه:</strong> مربع <strong>یک</strong> مستطیل است که طول و عرضش برابر است. پس <code>class Square extends Rectangle</code>.</li>
            <li><strong>مشکل:</strong> کلاس <code>Rectangle</code> متدی به نام <code>setWidth(double w)</code> دارد. اگر یک شی <code>Square</code> را به عنوان <code>Rectangle</code> به تابعی پاس دهیم، آن تابع حق دارد <code>setWidth</code> آن را تغییر دهد. این کار "مربع بودن" شیء را از بین می‌برد و رفتار غیرمنتظره‌ای ایجاد می‌کند.</li>
            <li><strong>نتیجه:</strong> <code>Square</code> نباید از <code>Rectangle</code> ارث‌بری کند، چون نمی‌تواند تمام قراردادهای والد را بدون تغییر معنای خود رعایت کند.</li>
        </ul>

        <h3>ج) ارث‌بری فقط برای استفاده مجدد از کد (Code Reuse Abuse)</h3>
        <ul>
            <li><strong>سناریوی غلط:</strong> شما یک کلاس <code>EmailSender</code> دارید که متد <code>send()</code> دارد. حالا یک کلاس <code>UserRegistration</code> می‌نویسید و چون پس از ثبت‌نام نیاز به ارسال ایمیل دارید، می‌نویسید: <code>class UserRegistration extends EmailSender</code>.</li>
            <li><strong>چرا غلط است؟</strong> چون <code>UserRegistration</code> <strong>یک</strong> <code>EmailSender</code> نیست.</li>
            <li><strong>راه حل صحیح:</strong> <strong>Composition</strong>.</li>
        </ul>
        <div class="code-block-container">
            <button class="copy-button" onclick="copyCode(this)">کپی</button>
            <pre><code class="language-java">class UserRegistration {
    private EmailSender sender; // HAS-A relationship

    public UserRegistration() {
        this.sender = new EmailSender();
    }

    public void register(User u) {
        // ... منطق ثبت‌نام
        sender.send(u.getEmail(), "Welcome!");
    }
}</code></pre>
        </div>
    </section>

    <section id="exercises">
        <h2>۷. تمرین‌های عملی</h2>

        <div class="exercise-box">
            <h3>تمرین ۱: سلسله‌مراتب Shape</h3>
            <p>یک کلاس <code>Shape</code> با فیلد <code>color</code> و متد <code>getArea()</code> (که 0.0 برمی‌گرداند) بسازید. سپس:</p>
            <ol>
                <li>کلاس <code>Rectangle</code> را از آن مشتق کنید (با <code>width</code> و <code>height</code>) و <code>getArea()</code> را بازنویسی کنید.</li>
                <li>کلاس <code>Circle</code> را از آن مشتق کنید (با <code>radius</code>) و <code>getArea()</code> را بازنویسی کنید.</li>
                <li>در <code>main</code>، یک شی از هر کدام بسازید و مساحتشان را چاپ کنید.</li>
            </ol>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۲: سلسله‌مراتب Employee</h3>
            <p>یک سیستم حقوق و دستمزد طراحی کنید:</p>
            <ul>
                <li>کلاس والد <code>Employee</code> با <code>name</code>, <code>id</code> و <code>baseSalary</code>.</li>
                <li>کلاس فرزند <code>Manager</code> که <code>bonus</code> هم دارد. متد <code>calculateTotalSalary</code> را بازنویسی کند.</li>
                <li>کلاس فرزند <code>Programmer</code> که <code>overtimeHours</code> و <code>hourlyRate</code> دارد. متد <code>calculateTotalSalary</code> را بازنویسی کند.</li>
                <li>از <code>super</code> در سازنده‌ها استفاده کنید.</li>
            </ul>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۳: کارآگاه روابط (IS-A vs. HAS-A)</h3>
            <p>برای هر جفت کلاس، تعیین کنید که رابطه باید <code>Inheritance</code> باشد یا <code>Composition</code> و دلیل خود را در یک خط بنویسید.</p>
            <ol>
                <li><code>Person</code> و <code>Address</code></li>
                <li><code>Post</code> (در وبلاگ) و <code>Comment</code></li>
                <li><code>Button</code> (دکمه گرافیکی) و <code>Rectangle</code> (شکل هندسی)</li>
                <li><code>Student</code> و <code>Person</code></li>
                <li><code>University</code> و <code>Department</code></li>
            </ol>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۴: پیش‌بینی خروجی زنجیره سازنده‌ها</h3>
            <p>خروجی دقیق کد زیر چیست؟ مراحل فراخوانی را روی کاغذ دنبال کنید.</p>
            <div class="code-block-container">
                <button class="copy-button" onclick="copyCode(this)">کپی</button>
                <pre><code class="language-java">class Base {
    Base() { System.out.print("Base-"); }
}
class Derived extends Base {
    Derived() {
        super();
        System.out.print("Derived-");
    }
}
class MoreDerived extends Derived {
    MoreDerived() { System.out.print("MoreDerived-"); }
}
// new MoreDerived();</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h3>تمرین ۵: طراحی سلسله‌مراتب Account در بانک</h3>
            <ul>
                <li>کلاس <code>Account</code> (شماره حساب، موجودی).</li>
                <li>کلاس <code>SavingsAccount</code> (حساب پس‌انداز) که از <code>Account</code> ارث می‌برد و <code>interestRate</code> (نرخ سود) دارد.</li>
                <li>کلاس <code>CheckingAccount</code> (حساب جاری) که از <code>Account</code> ارث می‌برد و <code>overdraftLimit</code> (سقف اضافه‌برداشت) دارد.</li>
                <li>متد <code>withdraw</code> را در هر کلاس طوری پیاده‌سازی کنید که قوانین خاص خود را رعایت کند (مثلاً حساب جاری تا سقف اضافه‌برداشت می‌تواند منفی شود).</li>
            </ul>
        </div>
    </section>

    <section id="summary">
        <h2>خلاصه بخش یازدهم</h2>
        <div class="summary-box">
            <ul>
                <li>✅ <strong>Inheritance (IS-A):</strong> مکانیزمی برای ایجاد کلاس جدید بر مبنای یک کلاس موجود، برای مدل‌سازی رابطه "هست یک".</li>
                <li>✅ <strong>extends:</strong> کلمه کلیدی برای ایجاد وراثت. جاوا فقط از وراثت یگانه (Single Inheritance) پشتیبانی می‌کند.</li>
                <li>✅ <strong>super():</strong> فراخوانی سازنده والد، که باید اولین دستور در سازنده فرزند باشد.</li>
                <li>✅ <strong>super.method():</strong> دسترسی به رفتار بازنویسی شده در کلاس والد.</li>
                <li>✅ <strong>@Override:</strong> انوتیشنی برای تضمین صحت بازنویسی متد و خوانایی کد.</li>
                <li>✅ <strong>protected:</strong> سطح دسترسی ایده‌آل برای اعضایی که باید توسط فرزندان دیده شوند اما از دنیای بیرون مخفی بمانند.</li>
                <li>✅ <strong>Composition over Inheritance:</strong> اصل طراحی کلیدی که می‌گوید ترکیب را بر ارث‌بری ترجیح دهید، مگر اینکه با یک رابطه IS-A واقعی و بدون ابهام روبرو باشید.</li>
                <li>✅ <strong>زنجیره سازنده‌ها (Constructor Chaining):</strong> هنگام ساخت یک شیء فرزند، زنجیره‌ای از فراخوانی سازنده‌ها از والد بزرگ تا فرزند اجرا می‌شود.</li>
            </ul>
        </div>

        <div class="next-section">
            <p><strong>در بخش بعدی:</strong> Upcasting و Downcasting — هنر تغییر دید</p>
            <div class="part-navigation">
                <a href="part10.html" class="btn-prev">→ بخش قبلی</a>
                <a href="part12.html" class="btn-next">بخش بعدی: Casting ←</a>
            </div>
        </div>
    </section>
</main>

<script src="../assets/js/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>

</body>
</html>