<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>فصل ۳: متغیرها، انواع داده و خطاها - جزوه برنامه سازی پیشرفته</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
</head>
<body class="theme-setup">

<div id="top-header">
    <button id="menu-toggle">☰</button>
    <h1 class="course-title" style="font-size: 1.1rem; color: inherit; font-weight: 600;">فصل ۳: متغیرها، انواع داده و
        خطاها</h1>
</div>
<div id="overlay"></div>

<nav id="sidebar">
    <div class="sidebar-profile">
        <a href="../index.html" title="بازگشت به صفحه اصلی">
            <img src="../assets/images/university_logo.png" alt="آرم دانشگاه - بازگشت به صفحه اصلی">
        </a>
        <h2 class="course-title">برنامه‌سازی پیشرفته (جاوا)</h2>
        <p class="instructor-name">مدرس: سید سجاد پیراهش</p>
    </div>
    <ul class="nav-menu">
        <li>
            <header>فهرست فصل ۳</header>
            <ul class="submenu open">
                <li><a href="#section3-1" class="nav-link active">۳-۱: انواع داده‌ها در جاوا</a></li>
                <li><a href="#section3-2" class="nav-link">۳-۲: بررسی انواع داده اولیه</a></li>
                <li><a href="#section3-3" class="nav-link">۳-۳: مدیریت حافظه: Stack و Heap</a></li>
                <li><a href="#section3-4" class="nav-link">۳-۴: انواع خطا در برنامه‌نویسی</a></li>
            </ul>
        </li>
    </ul>
    <div class="sidebar-footer">
        <a href="../index.html">→ بازگشت به فهرست اصلی</a>
    </div>
</nav>

<main id="main-content">

    <section id="section3-1">
        <h2>۳-۱: انواع داده‌ها در جاوا (Data Types)</h2>
        <p>اکنون که با ساختار کلی یک برنامه جاوا آشنا شدیم، وقت آن است که به سراغ اجزای سازنده منطق برنامه برویم:
            <strong>داده‌ها</strong>. در جاوا، هر متغیری که تعریف می‌کنید باید نوع مشخصی داشته باشد. این نوع، تعیین
            می‌کند که چه مقادیری را می‌توان در متغیر ذخیره کرد و چه عملیاتی روی آن قابل انجام است.</p>
        <p>انواع داده در جاوا به دو دسته اصلی تقسیم می‌شوند: <strong>انواع اولیه (Primitive Types)</strong> و <strong>انواع
            ارجاعی (Reference Types)</strong>. تفاوت اصلی این دو دسته در چیزی است که مستقیماً درون متغیر ذخیره می‌شود:
        </p>
        <ul>
            <li><strong>انواع داده اولیه (Primitive):</strong> خودِ <strong>مقدار داده</strong> را مستقیماً در حافظه
                نگهداری می‌کنند. این انواع، ساده و از پیش تعریف شده هستند.
            </li>
            <li><strong>انواع داده ارجاعی (Reference):</strong> به جای خود داده، یک <strong>آدرس (یا ارجاع)</strong> به
                مکانی در حافظه که داده اصلی (شیء) در آنجا قرار دارد را ذخیره می‌کنند. تمام کلاس‌ها، اینترفیس‌ها و
                آرایه‌ها از این نوع هستند.
            </li>
        </ul>

        <div class="diagram-container">
            <svg width="100%" height="300" viewBox="0 0 800 300" xmlns="http://www.w3.org/2000/svg"
                 font-family="Vazirmatn, sans-serif" direction="ltr">
                <defs>
                    <marker id="arrowhead-blue" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"
                            fill="#075985">
                        <polygon points="0 0, 8 3, 0 6"/>
                    </marker>
                    <filter id="shadow-light" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                        <feOffset dx="1" dy="1" result="offsetblur"/>
                        <feMerge>
                            <feMergeNode/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>

                <g transform="translate(480, 50)">
                    <rect x="0" y="0" width="280" height="180" fill="#F0F9FF" stroke="#BAE6FD" rx="10"/>
                    <text x="140" y="35" font-size="18" font-weight="bold" text-anchor="middle" fill="#0369A1" direction="rtl">نوع اولیه
                        (Primitive)
                    </text>
                    <text x="140" y="70" font-size="14" font-style="italic" text-anchor="middle" fill="#075985"
                          dir="ltr">int age = 30;
                    </text>
                    <rect x="40" y="100" width="200" height="50" fill="#fff" stroke="#7DD3FC"/>
                    <text x="140" y="130" font-size="24" font-weight="bold" text-anchor="middle" fill="#0C4A6E">30
                    </text>
                    <text x="250" y="130" font-size="14" text-anchor="middle" fill="#075985" direction="rtl">متغیر age</text>
                </g>

                <g transform="translate(40, 50)">
                    <rect x="0" y="0" width="320" height="210" fill="#F0F9FF" stroke="#BAE6FD" rx="10"/>
                    <text x="160" y="35" font-size="18" font-weight="bold" text-anchor="middle" fill="#0369A1" direction="rtl">نوع
                        ارجاعی (Reference)
                    </text>
                    <text x="160" y="70" font-size="14" font-style="italic" text-anchor="middle" fill="#075985"
                          dir="ltr">Student std = new Student();
                    </text>

                    <rect x="20" y="100" width="140" height="50" fill="#fff" stroke="#7DD3FC"/>
                    <text x="90" y="130" font-size="14" font-weight="600" text-anchor="middle" fill="#0C4A6E">
                        @15db9742
                    </text>
                    <text x="120" y="170" font-size="14" text-anchor="start" fill="#075985" direction="rtl">متغیر std</text>

                    <path d="M 160 125 L 200 125" stroke="#075985" stroke-width="2" marker-end="url(#arrowhead-blue)"/>

                    <rect x="200" y="100" width="100" height="100" fill="#E0F2FE" stroke="#38BDF8"/>
                    <text x="250" y="125" text-anchor="middle" fill="#082F49">آبجکت</text>
                    <text x="250" y="150" text-anchor="middle" fill="#082F49">Student</text>
                    <text x="250" y="180" font-size="12" text-anchor="middle" fill="#075985" dir="ltr">name: "Ali"
                    </text>
                </g>

                <text x="400" y="280" font-size="14" text-anchor="middle" fill="#0369A1">این تفاوت بنیادین، روی نحوه
                    تخصیص حافظه، سرعت و رفتار برنامه تأثیر مستقیم دارد.
                </text>
            </svg>
        </div>
    </section>

    <section id="section3-2">
        <h2>۳-۲: بررسی دقیق انواع داده اولیه (Primitives)</h2>
        <p>انواع داده اولیه، پایه‌ای‌ترین و ساده‌ترین واحدهای داده در جاوا هستند. این انواع داده مستقیماً توسط پردازنده
            قابل درک هستند و به همین دلیل سرعت بالایی دارند. جاوا دارای ۸ نوع داده اولیه است که به چهار گروه اصلی تقسیم
            می‌شوند.</p>

        <h3>۱. اعداد صحیح (Integer Types)</h3>
        <p>این گروه برای ذخیره اعداد بدون اعشار استفاده می‌شود. بسته به محدوده عددی که نیاز دارید، می‌توانید از یکی از
            چهار نوع زیر استفاده کنید:</p>
        <ul>
            <li><code>byte</code>: برای اعداد بسیار کوچک جهت صرفه‌جویی در حافظه.</li>
            <li><code>short</code>: برای اعداد کوتاه‌تر از `int`.</li>
            <li><code>int</code>: پراستفاده‌ترین نوع داده برای اعداد صحیح.</li>
            <li><code>long</code>: برای اعداد بسیار بزرگ که در محدوده `int` جای نمی‌گیرند.</li>
        </ul>

        <h3>۲. اعداد اعشاری (Floating-Point Types)</h3>
        <p>این گروه برای ذخیره اعداد دارای ممیز شناور (اعشاری) استفاده می‌شود:</p>
        <ul>
            <li><code>float</code>: برای اعداد اعشاری با دقت کمتر (حدود ۷ رقم اعشار).</li>
            <li><code>double</code>: پراستفاده‌ترین نوع برای اعداد اعشاری با دقت مضاعف (حدود ۱۵ رقم اعشار).</li>
        </ul>

        <h3>۳. کاراکتر (Character Type)</h3>
        <ul>
            <li><code>char</code>: برای ذخیره یک کاراکتر منفرد (مانند 'A' یا 'پ'). جاوا از استاندارد یونیکد (Unicode)
                برای ذخیره کاراکترها استفاده می‌کند.
            </li>
        </ul>

        <h3>۴. بولین (Boolean Type)</h3>
        <ul>
            <li><code>boolean</code>: فقط دو مقدار می‌تواند داشته باشد: <code>true</code> (درست) یا <code>false</code>
                (نادرست). این نوع داده برای نگهداری نتایج عبارات منطقی و شرطی استفاده می‌شود.
            </li>
        </ul>

        <div class="info-box" style="direction: ltr; text-align: left;">
            <h4>جدول مشخصات انواع داده اولیه</h4>
            <table style="width:100%; border-collapse: collapse; margin-top: 1rem;">
                <thead>
                <tr style="background-color: var(--primary-color); color: var(--background-color);">
                    <th style="padding: 10px; border: 1px solid var(--border-color);">Data Type</th>
                    <th style="padding: 10px; border: 1px solid var(--border-color);">Memory</th>
                    <th style="padding: 10px; border: 1px solid var(--border-color);">Default Value</th>
                    <th style="padding: 10px; border: 1px solid var(--border-color);">Wrapper Class</th>
                </tr>
                </thead>
                <tbody>
                <tr style="background-color: #f0f9ff;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>byte</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">1 Byte</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>0</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Byte</code></td>
                </tr>
                <tr style="background-color: #e0f2fe;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>short</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">2 Bytes</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>0</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Short</code></td>
                </tr>
                <tr style="background-color: #f0f9ff;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>int</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">4 Bytes</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>0</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Integer</code></td>
                </tr>
                <tr style="background-color: #e0f2fe;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>long</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">8 Bytes</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>0L</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Long</code></td>
                </tr>
                <tr style="background-color: #f0f9ff;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>float</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">4 Bytes</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>0.0f</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Float</code></td>
                </tr>
                <tr style="background-color: #e0f2fe;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>double</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">8 Bytes</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>0.0d</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Double</code></td>
                </tr>
                <tr style="background-color: #f0f9ff;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>char</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">2 Bytes</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>'\u0000'</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Character</code></td>
                </tr>
                <tr style="background-color: #e0f2fe;">
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>boolean</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);">1 bit</td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>false</code></td>
                    <td style="padding: 10px; border: 1px solid var(--border-color);"><code>Boolean</code></td>
                </tr>
                </tbody>
            </table>
        </div>

        <h3>کلاس‌های پوششی (Wrapper Classes)</h3>
        <p>همانطور که در جدول مشاهده می‌کنید، به ازای هر نوع داده اولیه، یک کلاس متناظر وجود دارد (مثلاً
            <code>int</code> و <code>Integer</code>). به این کلاس‌ها، <b>کلاس‌های پوششی</b> می‌گویند. آن‌ها به ما اجازه
            می‌دهند تا با انواع داده اولیه مانند اشیاء رفتار کنیم و از متدهای کاربردی آن‌ها استفاده کنیم. در فصل‌های
            آینده بیشتر با کاربرد این کلاس‌ها آشنا خواهیم شد.</p>

        <h3>نگاهی به حافظه: Primitive ها چگونه ذخیره می‌شوند؟</h3>
        <p>وقتی یک متغیر از نوع اولیه تعریف می‌کنید، کامپایلر دقیقاً می‌داند که چقدر فضا در حافظه به آن اختصاص دهد. این
            فضا در بخشی از حافظه به نام <b>Stack</b> تخصیص داده می‌شود که بسیار سریع و بهینه است. مقدار واقعی داده مستقیماً
            در همان مکان ذخیره می‌شود.</p>

        <div class="diagram-container">
            <svg width="100%" height="350" viewBox="0 0 800 350" xmlns="http://www.w3.org/2000/svg" font-family="Vazirmatn, sans-serif;" direction="ltr">
            <style>
                .code-text {
                    font-family: var(--code-font);
                    font-size: 15px;
                }

                .mem-addr {
                    fill: #075985;
                    font-size: 12px;
                }

                .mem-val {
                    fill: #0c4a6e;
                    font-weight: 600;
                }
            </style>
            <g transform="translate(520, 40)">
                <text x="140" y="0" font-size="18" font-weight="bold" text-anchor="middle" fill="#0369A1">کد برنامه
                </text>
                <text x="10" y="40" class="code-text">int score = 95;</text>
                <text x="10" y="70" class="code-text">short level = 10;</text>
                <text x="10" y="100" class="code-text">char grade = 'A';</text>
            </g>

            <g transform="translate(40, 40)">
                <text x="180" y="0" font-size="18" font-weight="bold" text-anchor="middle" fill="#0369A1" direction="rtl">نمایش در حافظه
                    (RAM)
                </text>
                <rect x="0" y="20" width="360" height="280" fill="#F0F9FF" stroke="#BAE6FD" rx="5"/>

                <text x="10" y="55" class="mem-addr">3000</text>
                <rect x="60" y="40" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>
                <text x="190" y="58" class="mem-val">95</text>
                <text x="10" y="80" class="mem-addr">3001</text>
                <rect x="60" y="65" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>
                <text x="10" y="105" class="mem-addr">3002</text>
                <rect x="60" y="90" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>
                <text x="10" y="130" class="mem-addr">3003</text>
                <rect x="60" y="115" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>

                <text x="10" y="180" class="mem-addr">3004</text>
                <rect x="60" y="165" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>
                <text x="190" y="183" class="mem-val">10</text>
                <text x="10" y="205" class="mem-addr">3005</text>
                <rect x="60" y="190" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>

                <text x="10" y="255" class="mem-addr">3006</text>
                <rect x="60" y="240" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>
                <text x="190" y="258" class="mem-val">'A'</text>
                <text x="10" y="280" class="mem-addr">3007</text>
                <rect x="60" y="265" width="280" height="25" fill="#E0F2FE" stroke="#7DD3FC"/>
            </g>

            <g transform="translate(420, 170)">
                <text x="180" y="0" font-size="16" font-weight="bold" text-anchor="middle" fill="#0369A1" direction="rtl">جدول نمادها
                    (Symbol Table)
                </text>
                <rect x="0" y="20" width="360" height="150" fill="#F0F9FF" stroke="#BAE6FD" rx="5"/>
                <line x1="0" y1="60" x2="360" y2="60" stroke="#BAE6FD"/>
                <line x1="120" y1="20" x2="120" y2="170" stroke="#BAE6FD"/>
                <line x1="240" y1="20" x2="240" y2="170" stroke="#BAE6FD"/>
                <text x="60" y="45" text-anchor="middle" font-weight="600">Variable</text>
                <text x="180" y="45" text-anchor="middle" font-weight="600">Data Type</text>
                <text x="300" y="45" text-anchor="middle" font-weight="600">Address</text>

                <text x="60" y="85" text-anchor="middle" class="code-text">score</text>
                <text x="180" y="85" text-anchor="middle" class="code-text">int</text>
                <text x="300" y="85" text-anchor="middle" class="code-text">3000</text>

                <text x="60" y="115" text-anchor="middle" class="code-text">level</text>
                <text x="180" y="115" text-anchor="middle" class="code-text">short</text>
                <text x="300" y="115" text-anchor="middle" class="code-text">3004</text>

                <text x="60" y="145" text-anchor="middle" class="code-text">grade</text>
                <text x="180" y="145" text-anchor="middle" class="code-text">char</text>
                <text x="300" y="145" text-anchor="middle" class="code-text">3006</text>
            </g>
            </svg>
        </div>
    </section>

    <section id="section3-3">
        <h2>۳-۳: مدیریت حافظه: Stack و Heap</h2>
        <p>برای درک عمیق تفاوت بین انواع داده اولیه و ارجاعی، باید با دو ناحیه اصلی حافظه که جاوا از آن‌ها استفاده
            می‌کند، آشنا شویم: <b>پشته (Stack)</b> و <b>هیپ (Heap)</b>.</p>
        <ul>
            <li><strong>حافظه Stack:</strong> یک ناحیه حافظه بسیار سریع و سازمان‌یافته است که برای ذخیره‌سازی <b>متغیرهای
                محلی (Local Variables)</b> و <b>فراخوانی متدها</b> استفاده می‌شود. تمام متغیرهای از نوع اولیه (Primitive)
                مستقیماً در این بخش از حافظه ذخیره می‌شوند. عمر داده‌ها در Stack کوتاه و مدیریت آن به صورت خودکار است.
            </li>
            <li><strong>حافظه Heap:</strong> یک ناحیه بزرگ‌تر و انعطاف‌پذیرتر از حافظه است که برای ذخیره‌سازی <b>اشیاء
                (Objects)</b> و آرایه‌ها استفاده می‌شود. هر زمان که از کلمه کلیدی <code>new</code> استفاده می‌کنیم، حافظه
                مورد نیاز برای آن شیء از Heap تخصیص داده می‌شود. مدیریت این فضا کمی پیچیده‌تر است و توسط بخشی به نام
                <b>Garbage Collector</b> در جاوا انجام می‌شود.
            </li>
        </ul>

        <h3>مثال گام به گام: حافظه در عمل</h3>
        <p>بیایید با یک مثال ببینیم که این دو ناحیه حافظه چگونه با هم کار می‌کنند. کد زیر را در نظر بگیرید:</p>
        <div class="code-block-container" style="direction: ltr;">
            <button class="copy-button">کپی</button>
            <pre><code class="language-java">
class Point {
    int x, y;
}

public class Main {
    public static void main(String[] args) {
        int a = 10;
        Point p1 = new Point();
        p1.x = 20;

        Point p2 = p1;
        p2.y = 30;
    }
}
        </code></pre>
        </div>

        <h4>تحلیل مرحله به مرحله حافظه</h4>
        <p>در ادامه، وضعیت حافظه Stack و Heap را پس از اجرای هر خط از متد `main` بررسی می‌کنیم.</p>
        <div class="diagram-container">
            <svg width="100%" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg"
                 font-family="Vazirmatn, sans-serif" direction="ltr">
                <style>
                    .code-text {
                        font-family: var(--code-font);
                        font-size: 14px;
                        fill: #075985;
                    }

                    .stack-box-bg {
                        fill: #F0F9FF;
                        stroke: #BAE6FD;
                    }

                    .heap-box-bg {
                        fill: #EEF2FF;
                        stroke: #A5B4FC;
                    }

                    .ref-line {
                        stroke: #4F46E5;
                        stroke-width: 2.5;
                        marker-end: url(#arrowhead-blue-v2);
                        fill: none;
                    }

                    .title-text {
                        font-size: 18px;
                        font-weight: bold;
                        text-anchor: middle;
                    }

                    .stack-item {
                        fill: #E0F2FE;
                        stroke: #7DD3FC;
                    }

                    .heap-item {
                        fill: #E0E7FF;
                        stroke: #818CF8;
                        rx: 5;
                    }

                    .strikethrough {
                        text-decoration: line-through;
                    }

                    .red-bold {
                        fill: #B91C1C;
                        font-weight: bold;
                    }
                </style>

                <defs>
                    <marker id="arrowhead-blue-v2" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"
                            fill="#4F46E5">
                        <polygon points="0 0, 8 3, 0 6"/>
                    </marker>
                </defs>

                <text x="500" y="30" class="title-text" fill="#4338CA" direction="rtl">حافظه Heap</text>
                <rect x="300" y="40" width="450" height="340" class="heap-box-bg" rx="10"/>
                <text x="140" y="30" class="title-text" fill="#0369A1" direction="rtl">حافظه Stack</text>
                <rect x="25" y="40" width="230" height="340" class="stack-box-bg" rx="10"/>

                <text x="30" y="70" text-anchor="start" class="code-text">int a = 10;</text>
                <g transform="translate(45, 80)">
                    <rect width="190" height="40" class="stack-item"/>
                    <text x="95" y="25" text-anchor="middle">a: 10</text>
                </g>

                <text x="30" y="145" text-anchor="start" class="code-text">Point p1 = new Point();</text>
                <g transform="translate(45, 155)">
                    <rect width="190" height="40" class="stack-item"/>
                    <text x="95" y="25" text-anchor="middle">p1: @50ab23</text>
                </g>
                <g transform="translate(425, 120)">
                    <rect width="200" height="80" class="heap-item"/>
                    <text x="100" y="25" text-anchor="middle" font-weight="bold">Point Object</text>
                    <text x="100" y="48" text-anchor="middle" font-size="12" fill="#312E81">Address: @50ab23</text>
                    <text x="100" y="70" text-anchor="middle">x: 0, y: 0</text>
                </g>
                <path d="M 235 175 C 330 175, 330 160, 425 160" class="ref-line"/>

                <text x="30" y="225" text-anchor="start" class="code-text">p1.x = 20;</text>
                <g transform="translate(515, 180)">
                    <text x="0" y="0" class="strikethrough">0</text>
                    <text x="0" y="0" class="red-bold" dx="15">20</text>
                </g>

                <text x="30" y="260" text-anchor="start" class="code-text">Point p2 = p1;</text>
                <g transform="translate(45, 270)">
                    <rect width="190" height="40" class="stack-item"/>
                    <text x="95" y="25" text-anchor="middle">p2: @50ab23</text>
                </g>
                <path d="M 235 290 C 330 290, 330 180, 425 180" class="ref-line"/>

                <text x="30" y="340" text-anchor="start" class="code-text">p2.y = 30;</text>
                <g transform="translate(545, 180)">
                    <text x="0" y="0" class="strikethrough">0</text>
                    <text x="0" y="0" class="red-bold" dx="15">30</text>
                </g>
            </svg>
        </div>

        <div class="info-box">
            <h4>نکات کلیدی از مثال بالا</h4>
            <ul>
                <li>متغیر <code>a</code> از نوع اولیه <code>int</code> است، بنابراین مقدار <code>10</code> مستقیماً در
                    Stack ذخیره شده است.
                </li>
                <li>متغیرهای <code>p1</code> و <code>p2</code> از نوع ارجاعی <code>Point</code> هستند. خود این متغیرها
                    در Stack قرار دارند، اما مقداری که در آن‌ها ذخیره شده است، <strong>مقدار خود شیء نیست</strong>، بلکه
                    <strong>آدرس</strong> آن شیء در حافظه Heap است.
                </li>
                <li>چون <code>p1</code> و <code>p2</code> هر دو به یک آدرس یکسان اشاره می‌کنند، در واقع به <strong>یک
                    شیء واحد</strong> اشاره دارند. به همین دلیل، وقتی مقدار <code>y</code> را از طریق <code>p2</code>
                    تغییر می‌دهیم، این تغییر از طریق <code>p1</code> نیز قابل مشاهده است.
                </li>
                <li>اگر یک متغیر ارجاعی هنوز به هیچ شیئی اشاره نکند (مقداردهی اولیه با <code>new</code> نشده باشد)،
                    مقدار پیش‌فرض آن <code>null</code> خواهد بود. تلاش برای دسترسی به اعضای یک متغیر <code>null</code>
                    منجر به خطای معروف <code>NullPointerException</code> در زمان اجرا می‌شود.
                </li>
            </ul>
        </div>
    </section>

    <section id="section3-4">
        <h2>۳-۴: انواع خطا در برنامه‌نویسی</h2>
        <p>هیچ برنامه‌نویسی از خطا (Bug) مصون نیست. خطاها بخش جدایی‌ناپذیر فرآیند توسعه نرم‌افزار هستند. یک برنامه‌نویس خوب کسی نیست که هرگز خطا نمی‌کند، بلکه کسی است که انواع خطاها را می‌شناسد و می‌داند چگونه آن‌ها را به سرعت پیدا و رفع کند. به طور کلی، خطاها در برنامه‌نویسی به سه دسته اصلی تقسیم می‌شوند.</p>

        <h3>۱. خطای کامپایل (Syntax Error / Compile-time Error)</h3>
        <p>این خطاها ساده‌ترین نوع خطا برای پیدا کردن هستند. خطای کامپایل زمانی رخ می‌دهد که شما قوانین و "گرامر" زبان برنامه‌نویسی را رعایت نکرده باشید. کامپایلر جاوا (<code>javac</code>) قبل از اینکه حتی بتواند برنامه را به بایت‌کد تبدیل کند، این خطاها را تشخیص داده و با یک پیام مشخص، محل دقیق و نوع خطا را به شما اطلاع می‌دهد. تا زمانی که تمام خطاهای سینتکسی رفع نشوند، برنامه شما هرگز اجرا نخواهد شد.</p>
        <p><strong>مثال‌های رایج:</strong></p>
        <ul>
            <li>فراموش کردن نقطه ویرگول (<code>;</code>) در انتهای یک دستور.</li>
            <li>اشتباه تایپی در کلمات کلیدی (مثلاً نوشتن <code>public static void main</code> به صورت <code>publc static void main</code>).</li>
            <li>عدم تطابق پرانتزها <code>()</code> یا آکولادها <code>{}</code>.</li>
        </ul>
        <div class="code-block-container" style="direction: ltr;">
            <button class="copy-button">کپی</button>
            <pre><code class="language-java">
public class SyntaxErrorExample {
    public static void main(String[] args) {
        int number = 10
        System.out.println("The number is: " + number);
    }
}
    </code></pre>
        </div>
        <p>در مثال بالا، کامپایلر یک خطا با این مضمون گزارش خواهد داد: <code>';' expected</code>، و به شما می‌گوید که در انتهای خط اول متد `main`، یک نقطه ویرگول فراموش شده است.</p>

        <h3>۲. خطای زمان اجرا (Runtime Error / Exception)</h3>
        <p>این خطاها پیچیده‌تر هستند، زیرا برنامه از نظر سینتکسی کاملاً صحیح است و با موفقیت کامپایل می‌شود، اما در حین <b>اجرا</b> به یک وضعیت پیش‌بینی نشده یا غیرممکن برخورد می‌کند. در این حالت، JVM اجرای برنامه را متوقف کرده و یک "استثنا" (Exception) پرتاب می‌کند که معمولاً باعث بسته شدن ناگهانی برنامه می‌شود.</p>
        <p><strong>مثال‌های رایج:</strong></p>
        <ul>
            <li><strong><code>ArithmeticException</code>:</strong> تلاش برای تقسیم یک عدد بر صفر.</li>
            <li><strong><code>NullPointerException</code>:</strong> تلاش برای استفاده از یک متغیر ارجاعی که مقدار آن <code>null</code> است.</li>
            <li><strong><code>ArrayIndexOutOfBoundsException</code>:</strong> تلاش برای دسترسی به خانه‌ای از آرایه که وجود ندارد (مثلاً دسترسی به ایندکس ۵ در آرایه‌ای با طول ۵).</li>
        </ul>
        <div class="code-block-container" style="direction: ltr;">
            <button class="copy-button">کپی</button>
            <pre><code class="language-java">
public class RuntimeErrorExample {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30};
        // This line will cause an error because index 3 does not exist.
        System.out.println(numbers[3]);
    }
}
    </code></pre>
        </div>
        <p>اجرای کد بالا باعث ایجاد یک خطای <code>ArrayIndexOutOfBoundsException</code> می‌شود، زیرا بزرگترین ایندکس مجاز در آرایه <code>numbers</code>، ایندکس ۲ است.</p>

        <h3>۳. خطای منطقی (Logical Error)</h3>
        <p>این خطاها معمولاً <b>سخت‌ترین نوع خطا برای شناسایی و رفع</b> هستند. در یک خطای منطقی، برنامه شما بدون هیچ مشکلی کامپایل و اجرا می‌شود و هیچ پیامی مبنی بر خطا نمایش نمی‌دهد، اما نتیجه‌ای که تولید می‌کند، <b>اشتباه</b> است. این خطاها به دلیل اشتباه در منطق و الگوریتم برنامه رخ می‌دهند، نه در گرامر زبان.</p>
        <p><strong>مثال رایج:</strong></p>
        <p>فرض کنید می‌خواهیم میانگین دو عدد را محاسبه کنیم. ممکن است کد زیر را بنویسیم:</p>
        <div class="code-block-container" style="direction: ltr;">
            <button class="copy-button">کپی</button>
            <pre><code class="language-java">
public class LogicalErrorExample {
    public static void main(String[] args) {
        double num1 = 10;
        double num2 = 20;
        // Incorrect logic due to operator precedence
        double average = num1 + num2 / 2; // This calculates 10 + (20/2) = 20.0
        System.out.println("The average is: " + average); // Prints 20.0, which is wrong

        // Correct logic
        double correctAverage = (num1 + num2) / 2; // This calculates (10+20)/2 = 15.0
        System.out.println("The correct average is: " + correctAverage); // Prints 15.0
    }
}
    </code></pre>
        </div>
        <p>در این مثال، به دلیل اولویت عملگرها، ابتدا عمل تقسیم انجام می‌شود. برنامه هیچ خطایی نمی‌دهد، اما نتیجه آن چیزی نیست که ما انتظار داشتیم. پیدا کردن این نوع خطاها نیازمند تست دقیق و استفاده از ابزارهای خطایابی (Debugger) برای دنبال کردن مرحله به مرحله اجرای برنامه است.</p>

        <div class="chapter-nav">
            <a href="chapter2.html">→ رفتن به فصل قبل: مقدمات جاوا</a>
            <a href="chapter4.html">رفتن به فصل بعد ←</a>
        </div>
    </section>


</main>

<script src="../assets/js/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>